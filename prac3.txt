(big-bang <estado_inicial>
	[<evento> <manejador_evento>]
	[to-draw <controlador_de_pantalla>]
	[on-key <manejador_de_teclado>]
	[on-mouse <manejador_de_mouse>]
	[on-tick <manejador_de_reloj>]
	...
	[stop-when <predeterminado fin de ejecucion>]
	
; Cuando se presiona el 0 se muestra un circulo, si se presiona 1 un cuadrado y si se pone el 2 un triangulo. Arracna con circulo.
; Que vaya cambiando constantemente en este orden: circulo, cuadrado, triangulo.
; Si se presiona la letra x se para el programa y muestra CHAU
; OBSERVACION: Las funciones de manejo de to-draw siempre toman un estado y devuelven una funcion, el estado se pasa solo y no por parametros.

; Cuando se presiona el 0 se muestra un circulo, si se presiona 1 un cuadrado y si se pone el 2 un triangulo. Arracna con circulo.
; Que vaya cambiando constantemente en este orden: circulo, cuadrado, triangulo.
; Si se presiona la letra x se para el programa y muestra CHAU
;Estado es String

(define EINICIAL "c")
(define ALTO 400)
(define ANCHO 400)
(define ESCENA (empty-scene ALTO ANCHO "black"))
(define TAM 100)
(define TRIANGULO (triangle TAM "solid" "green"))
(define CUADRADO (square TAM "solid" "red"))
(define CIRCULO (circle (/ TAM 2) "solid" "yellow"))
(define BOLUDO .)

(define (dibujar e) (
                     cond
                       [(string=? e "t") TRIANGULO]
                       [(string=? e "q") CUADRADO]
                       [(string=? e "c") CIRCULO]
                       [(string=? e "b") BOLUDO]
                       
                     )
  )
;interpretar: Estado -> String
(define (interpretar e) 
           (place-image (dibujar e) (/ ALTO 2) (/ ANCHO 2)
                        ESCENA)
         
  )

;manejaTeclado: Estado String -> Estado
;check-expect toma una funcion y un resultado esperado

(define (manejaTeclado e tecla) (cond
                       [(string=? tecla "t") "t"]
                       [(string=? tecla "q") "q"]
                       [(string=? tecla "c") "c"]
                       [(string=? tecla "b") "b"]
                       [else e]))

(check-expect (manejaTeclado "q" "q") "q")
(check-expect (manejaTeclado "c" "q") "q")
(check-expect (manejaTeclado "q" "c") "c")
(check-expect (manejaTeclado "h" "c") "c")

;manejaReloj Estado -> Estado
(define (manejaReloj e)

(big-bang EINICIAL
  [to-draw interpretar]
  [on-key manejaTeclado]
  [on-tick manejaReloj 2] ;Cada dos segundos ejecuta manejaReloj
  )


;;Practica 3
#|2) Escriba un programa que dibuje un círculo color azul de
radio 100 el cual vaya disminuyendo su tamaño con el paso del tiempo
(es decir, con cada tick del reloj). Reiniciar con r y finalizar con s.
|#
(require 2htdp/image)
(define RAD_INICIAL 100)
(define (CIRCULO r) (circle r "solid" "blue"))

(define (interpretar r) (
                         place-image (CIRCULO r) 150 150 (empty-scene 300 300)
                         ))

(define (clockHandler r) (
                          cond [(= r 0) 100]
                               [else (- r 1)]
                          ))

(define (keyHandler r tecla) (
                               cond [(string=? tecla "r") 100]
                                    [(string=? tecla "s") 150]
                                    [else r]
                               ))

(define (stopHandler r) (= r 150))

(big-bang RAD_INICIAL
  [to-draw interpretar]
  [on-key keyHandler]
  [on-tick clockHandler]
  [stop-when stopHandler interpretar] ;interpretar funciona como la funcion que se hace cuando termina
  )


#|8)
En este ejercicio agregaremos estrellas a un cielo vacío. El
estado del sistema será una imagen, nuestro cielo, sobre la cual
incorporaremos las estrellas que vayamos dibujando. Defina constantes
para representar el color, el ancho y el alto de la escena, así como
también el color y el tamaño de las estrellas. Genere una expresión
big-bang tal que:
• El estado inicial del sistema sea FONDO (el cielo vacío).
• La función que responde a la cláusula to-draw dibuje el estado
actual.
• Al clickear sobre el cielo, se dibuje una estrella donde se realizó el
click, respetando el tamaño y el color definidos previamente.
• Puede suceder que una estrella no entre completamente en la
escena. Modifique sus funciones para que ésto no ocurra, es decir
que una estrella se grafique sólo si va a entrar completamente en el
cielo. Caso contrario, la imagen no debe modificarse.
• Si se presiona backspace, todas las estrellas deben desaparecer, es
decir, el cielo debe volver al estado inicial.
• Por último, modifique sus funciones para que el tamaño de las
estrellas varíe de acuerdo a la posición donde se produjo el click,
cuanto más a la izquierda sea, más pequeñas deben ser.
|#
(define ANCHO 600)
(define ALTO 600)
(define (REST x) (+ 30 (/ x 10)))

(define CCielo "black")
(define CEst "white")
(define EstiloEstrella "solid")

(define (ESTRELLA l) (star l EstiloEstrella CEst))

(define FONDO (
               empty-scene ANCHO ALTO CCielo)
  )

(define (checklimites x y )
  (cond
    [(< x (REST x)) #false]
    [(< y (REST x)) #false]
    [(> x (- 600 (REST x))) #false]
    [(> y (- 600 (REST x))) #false]
    [else #true]
   )
  )


(define (dibuja r x y)
  (cond [(checklimites x y) ( place-image (ESTRELLA (REST x)) x y r)]
        [else r])
)


(define (interpretar r) r)

(define (mouseHandler r x y event) (
                   if (string=? event "button-down") (
                      dibuja r x y  
                                                       ) r
                    
         )
)

(define (keyHandler r key) (cond [(string=? key "r") FONDO]))

(big-bang FONDO
  [to-draw interpretar]
  [on-mouse mouseHandler]
  [on-key keyHandler]
  )
