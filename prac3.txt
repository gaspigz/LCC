(big-bang <estado_inicial>
	[<evento> <manejador_evento>]
	[to-draw <controlador_de_pantalla>]
	[on-key <manejador_de_teclado>]
	[on-mouse <manejador_de_mouse>]
	[on-tick <manejador_de_reloj>]
	...
	[stop-when <predeterminado fin de ejecucion>]
	
; Cuando se presiona el 0 se muestra un circulo, si se presiona 1 un cuadrado y si se pone el 2 un triangulo. Arracna con circulo.
; Que vaya cambiando constantemente en este orden: circulo, cuadrado, triangulo.
; Si se presiona la letra x se para el programa y muestra CHAU
; OBSERVACION: Las funciones de manejo de to-draw siempre toman un estado y devuelven una funcion, el estado se pasa solo y no por parametros.

; Cuando se presiona el 0 se muestra un circulo, si se presiona 1 un cuadrado y si se pone el 2 un triangulo. Arracna con circulo.
; Que vaya cambiando constantemente en este orden: circulo, cuadrado, triangulo.
; Si se presiona la letra x se para el programa y muestra CHAU
;Estado es String

(define EINICIAL "c")
(define ALTO 400)
(define ANCHO 400)
(define ESCENA (empty-scene ALTO ANCHO "black"))
(define TAM 100)
(define TRIANGULO (triangle TAM "solid" "green"))
(define CUADRADO (square TAM "solid" "red"))
(define CIRCULO (circle (/ TAM 2) "solid" "yellow"))
(define BOLUDO .)

(define (dibujar e) (
                     cond
                       [(string=? e "t") TRIANGULO]
                       [(string=? e "q") CUADRADO]
                       [(string=? e "c") CIRCULO]
                       [(string=? e "b") BOLUDO]
                       
                     )
  )
;interpretar: Estado -> String
(define (interpretar e) 
           (place-image (dibujar e) (/ ALTO 2) (/ ANCHO 2)
                        ESCENA)
         
  )

;manejaTeclado: Estado String -> Estado
;check-expect toma una funcion y un resultado esperado

(define (manejaTeclado e tecla) (cond
                       [(string=? tecla "t") "t"]
                       [(string=? tecla "q") "q"]
                       [(string=? tecla "c") "c"]
                       [(string=? tecla "b") "b"]
                       [else e]))

(check-expect (manejaTeclado "q" "q") "q")
(check-expect (manejaTeclado "c" "q") "q")
(check-expect (manejaTeclado "q" "c") "c")
(check-expect (manejaTeclado "h" "c") "c")

;manejaReloj Estado -> Estado
(define (manejaReloj e)

(big-bang EINICIAL
  [to-draw interpretar]
  [on-key manejaTeclado]
  [on-tick manejaReloj 2] ;Cada dos segundos ejecuta manejaReloj
  )


;;Practica 3
#|2) Escriba un programa que dibuje un círculo color azul de
radio 100 el cual vaya disminuyendo su tamaño con el paso del tiempo
(es decir, con cada tick del reloj). Reiniciar con r y finalizar con s.
|#
(require 2htdp/image)
(define RAD_INICIAL 100)
(define (CIRCULO r) (circle r "solid" "blue"))

(define (interpretar r) (
                         place-image (CIRCULO r) 150 150 (empty-scene 300 300)
                         ))

(define (clockHandler r) (
                          cond [(= r 0) 100]
                               [else (- r 1)]
                          ))

(define (keyHandler r tecla) (
                               cond [(string=? tecla "r") 100]
                                    [(string=? tecla "s") 150]
                                    [else r]
                               ))

(define (stopHandler r) (= r 150))

(big-bang RAD_INICIAL
  [to-draw interpretar]
  [on-key keyHandler]
  [on-tick clockHandler]
  [stop-when stopHandler interpretar] ;interpretar funciona como la funcion que se hace cuando termina
  )


#|8)
En este ejercicio agregaremos estrellas a un cielo vacío. El
estado del sistema será una imagen, nuestro cielo, sobre la cual
incorporaremos las estrellas que vayamos dibujando. Defina constantes
para representar el color, el ancho y el alto de la escena, así como
también el color y el tamaño de las estrellas. Genere una expresión
big-bang tal que:
• El estado inicial del sistema sea FONDO (el cielo vacío).
• La función que responde a la cláusula to-draw dibuje el estado
actual.
• Al clickear sobre el cielo, se dibuje una estrella donde se realizó el
click, respetando el tamaño y el color definidos previamente.
• Puede suceder que una estrella no entre completamente en la
escena. Modifique sus funciones para que ésto no ocurra, es decir
que una estrella se grafique sólo si va a entrar completamente en el
cielo. Caso contrario, la imagen no debe modificarse.
• Si se presiona backspace, todas las estrellas deben desaparecer, es
decir, el cielo debe volver al estado inicial.
• Por último, modifique sus funciones para que el tamaño de las
estrellas varíe de acuerdo a la posición donde se produjo el click,
cuanto más a la izquierda sea, más pequeñas deben ser.
|#
(define ANCHO 600)
(define ALTO 600)
(define (REST x) (+ 30 (/ x 10)))

(define CCielo "black")
(define CEst "white")
(define EstiloEstrella "solid")

(define (ESTRELLA l) (star l EstiloEstrella CEst))

(define FONDO (
               empty-scene ANCHO ALTO CCielo)
  )

(define (checklimites x y )
  (cond
    [(< x (REST x)) #false]
    [(< y (REST x)) #false]
    [(> x (- 600 (REST x))) #false]
    [(> y (- 600 (REST x))) #false]
    [else #true]
   )
  )


(define (dibuja r x y)
  (cond [(checklimites x y) ( place-image (ESTRELLA (REST x)) x y r)]
        [else r])
)


(define (interpretar r) r)

(define (mouseHandler r x y event) (
                   if (string=? event "button-down") (
                      dibuja r x y  
                                                       ) r
                    
         )
)

(define (keyHandler r key) (cond [(string=? key "r") FONDO]))

(big-bang FONDO
  [to-draw interpretar]
  [on-mouse mouseHandler]
  [on-key keyHandler]
  )
  
  
#|Ejercicio 10. Busque en internet dos imágenes de huellas, un pie
derecho y un pie izquierdo.
Defina estas imágenes como dos constantes
PIEDER Y PIEIZQ, respectivamente.
Se pide escribir un programa que simule una persona caminando que
avance en línea recta de izquierda a derecha o de derecha a izquierda
sobre una imagen vacía, a razón de un número impar de píxeles con
cada tick del reloj.
Tener en cuenta la orientación de las huellas según
el sentido en que se avanza. Si llega a un extremo de la escena se
considera que la persona gira y se dirige hacia el otro extremo.
El estado del programa interactivo guardará la posicion central del pie
que se encuentre apoyado en un momento dado.

Se arranca con un pie apoyado mirando hacia la derecha. El pie que se dibuja sera el
izquierdo si el estado es par o el derecho si es impar. Los pies deben
aparecer enteros, no se permite una huella cortada.
Defina todas las constantes que considere necesarias. Modifique el
programa para que:
• al presionar la barra espaciadora, vuelva la huella a la posición
inicial,
• al hacer click sobre la imagen, se dibuje una huella en la
coordenada horizontal donde se produjo el evento (dependiendo de
la paridad se debera dibujar uno u otro pie)
|#

(define PIEIZQ (rotate 270 .))
(define PIEDER (rotate 270 .))

(define ANCHO 1400)
(define ALTO 400)

(define SCN (empty-scene ANCHO ALTO))

(define (pies x1 x2 s) (
                        if (= s 1) (place-image PIEDER x1 300 (place-image PIEIZQ x2 100  SCN)) (place-image (rotate 180 PIEDER) x1 100 (place-image (rotate 180 PIEIZQ) x2 300  SCN))
                            
                        )
  );SI S ES TRUE AVANZA

(define (dibujar e) (
                     cond
                      [(= 100 e) (pies 100 -100 1)]
                      [(< e (- ANCHO 100)) (if (odd? e) (pies e (- e 95) 1) (pies (- e 95) e 1))]
                      [(> e (+ ANCHO 100)) (if (odd? e)
                                                (pies (- (- ANCHO 100) (- e (+ ANCHO 100))) (+ 95 (- (- ANCHO 100) (- e (+ ANCHO 100)))) 0)
                                                (pies (+ 95 (- (- ANCHO 100) (- e (+ ANCHO 100)))) (- (- ANCHO 100) (- e (+ ANCHO 100))) 0))]
                      [else (pies (- (- ANCHO 100) (- e ANCHO)) (- (- ANCHO 100) (- e ANCHO)) 0)]
                      ;[else (pies e e 0)]
                     )
  )

(define (caminar e ) (cond
                       [(< e (- (* 2 ANCHO) 200)) (+ 95 e)]
                       [(and (>= e (- ANCHO 100)) (< e (+ ANCHO 100))) (+ ANCHO 100)]
                       [else 100]
                       )
                     )

#|
(cond
                       [(= (modulo e 2) 0) ()]
                       [else ()]
                       )
|#

(big-bang 100

  [to-draw dibujar]
  [on-tick caminar 0.2]
  
  )

